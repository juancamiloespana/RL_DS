# -*- coding: utf-8 -*-
"""Copia 4 MODELO LOTKA-VOLTERRA

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LHQZVYx6ktYqfoNkDApQ6Oltciz-iNJL
"""

# Importar libreria para calcular la media
import numpy as np

class LotkaVolterraModel:
    def __init__(self, alpha, beta, delta, gamma, initial_rabbits=100, initial_wolves=25, dt=0.01, total_time=40000):
        self.alpha = alpha
        self.beta = beta
        self.delta = delta
        self.gamma = gamma
        self.initial_rabbits = initial_rabbits
        self.initial_wolves = initial_wolves
        self.dt = dt
        self.total_time = int(total_time)
        self.L = [0]
        self.R = [self.initial_rabbits]
        self.W = [self.initial_wolves]

    def simulate(self):

        for i in range(self.total_time):

            if i == 0:
                wolves = self.initial_wolves
                rabbits = self.initial_rabbits
            else:
                wolves += (wolves_birth - wolves_death) * self.dt
                rabbits += (rabbits_birth - rabbits_death)* self.dt

            wolves_birth = self.alpha * (rabbits * wolves)
            wolves_death = self.beta * wolves

            rabbits_birth = self.delta * rabbits
            rabbits_death = self.gamma * (rabbits * wolves)

            self.L.append(wolves)
            self.R.append(rabbits)
            self.W.append(wolves)

        return np.mean(self.L),  np.mean(self.R)


"""# Eficiencia e-greedy"""

import numpy as np
import random
import time
import pandas as pd

##############################################################################################################################
# FUNCIÓN

def Cumple_Limites(parametros, limites):
    for i, valor in enumerate(parametros):
        if not (limites[i][0] <= valor <= limites[i][1]):
            return False
    return True

##############################################################################################################################

E_values = [0.1, 0.15, 0.2, 0.25] # MODIFICABLEEEEEEES
Runs_values = [3000, 5000, 10000, 20000]

fac = [-0.1, -0.05, -0.01, 0, 0.01, 0.05, 0.1]
P = [0.002, 0.04, 0.1, 0.0025]
Lim = [[0.0015, 0.0025], [0.03, 0.05], [0.05, 0.15], [0.002, 0.003]]
A = len(fac)
n_episodios = 3

results = [] # Para la tabla de resultados

for Runs in Runs_values:
    for E in E_values:
        start_time = time.time()
        iteraciones = []  # Para almacenar el número de iteración dónde la recompensa se estabiliza
        y_final_episodio = []  # Para almacenar el valor de la recompensa final en cada episodio

        for j in range(n_episodios):
            P = [0.002, 0.04, 0.1, 0.0025]  # Valor inicial de los parámetros
            Q = np.zeros((A, A, A, A))
            Dim = Q.ndim
            y = np.array([P[0]])

            for i in range(Runs):
                P_previo = list(P)  # Guardar el valor de P previo
                lotka_volterra_instance = LotkaVolterraModel(*P_previo)
                R_previo, rabbits_previo = lotka_volterra_instance.simulate()

                y = np.append(y, R_previo)

                if E < random.random(): # Explotar
                    max_val = np.amax(Q)
                    result = np.where(Q == max_val)
                    I, J, K, L = [result[i][0] for i in range(Dim)] # Impresición en el código
                else: # Explorar
                    idxs = [0] * Dim
                    I, J, K, L = [random.randint(0, A-1) for items in idxs]  # Generar una posición aleatoria

                # Asignar un nuevo P de acuerdo a la posición elegida
                P[0] = P[0] * (1 + fac[I])
                P[1] = P[1] * (1 + fac[J])
                P[2] = P[2] * (1 + fac[K])
                P[3] = P[3] * (1 + fac[L])

                # Verificar que esta nueva solución P no viole los límites de factibilidad
                if Cumple_Limites(P, Lim):
                    lotka_volterra_instance = LotkaVolterraModel(*P)  # Calcular su recompensa
                    R_actual, rabbits_actual = lotka_volterra_instance.simulate()
                    Q[I][J][K][L] += ((R_actual - R_previo) / R_previo)

                    if R_previo >= R_actual:
                        P = P_previo
                else:
                    Q[I][J][K][L] += -100
                    P = P_previo

                # Almacenar el número de la iteración (i) dónde se estabiliza la recompensa (o sea, la última)
                if i == Runs-1:
                    iteracion_converge = np.where(y == R_previo)[0][0]
                    iteraciones.append(iteracion_converge + 1)
                    y_final_episodio.append(R_previo)

        end_time = time.time()
        tiempo_ejecucion = (end_time - start_time) / 60

        # MÉTRICAS
        recompensa_final_promedio = np.mean(y_final_episodio) # Promedio de la recompensa final
        recompensa_final_desviacion = np.std(y_final_episodio)
        promedio_iteracion = np.mean(iteraciones)
        desviación_iteracion = np.std(iteraciones)

        # RESULTADOS
        results.append({
            'Runs': Runs,
            'E': E,
            'Recompensa Final Promedio': recompensa_final_promedio,
            'Recompensa Final Promedio (Desv.)': recompensa_final_desviacion,
            'Promedio Iteracion': promedio_iteracion,
            'Promedio Iteracion (Desv.)': desviación_iteracion,
            '% iteraciones necesitadas': promedio_iteracion / Runs,
            'Tiempo Ejecucion (min)': tiempo_ejecucion
        })

df_results = pd.DataFrame(results)
df_results


import pandas as pd
import numpy as np


df=pd.read_csv('resultados\datos_egreedy_lotka_volterra.csv')

df.head()



import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

df["Consecutive"] = df.groupby("Episodio").cumcount()


grouped = df.groupby("Consecutive")["R_actual"].agg(
    mean="mean",
    std="std",
    count="count"
).reset_index()

# Calculate 95% Confidence Interval
grouped["sem"] = grouped["std"] / np.sqrt(grouped["count"])  # Standard Error
grouped["ci_upper"] = grouped["mean"] + 1.96 * grouped["sem"]  # Upper bound
grouped["ci_lower"] = grouped["mean"] - 1.96 * grouped["sem"]  # Lower bound

# Plot the Data
plt.figure(figsize=(10, 6))
plt.plot(grouped["Consecutive"], grouped["mean"], label="Mean", marker="", color="blue")
plt.fill_between(
    grouped["Consecutive"],
    grouped["ci_lower"],
    grouped["ci_upper"],
    color="blue",
    alpha=0.2,
    label="95% Confidence Interval"
)

# Customize the Plot
plt.title("R_actual with 95% Confidence Interval (Grouped by Consecutive)", fontsize=14)
plt.xlabel("Consecutive", fontsize=12)
plt.ylabel("R_actual", fontsize=12)
plt.legend()
plt.grid(True)
plt.show()
